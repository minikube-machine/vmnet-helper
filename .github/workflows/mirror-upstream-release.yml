---
name: mirror-upstream-release

'on':
  schedule:
    - cron: '0 10 * * *'
  workflow_dispatch:

jobs:
  discover:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      tags: ${{ steps.tags.outputs.tags }}
      latest_tag: ${{ steps.tags.outputs.latest_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.MIRROR_TOKEN }}
      - name: Configure git
        run: |
          git config user.name github-actions[bot]
          git config user.email github-actions[bot]@users.noreply.github.com
      - name: Determine tags to mirror
        id: tags
        env:
          GH_TOKEN: ${{ secrets.MIRROR_TOKEN }}
        run: |
          set -euo pipefail
          git remote add upstream https://github.com/nirs/vmnet-helper.git
          git fetch upstream --tags
          upstream_tags=$(git ls-remote --refs --tags upstream | \
            awk '{print $2}' | sed 's|refs/tags/||' | sort -V)
          origin_tags=$(git ls-remote --refs --tags origin 2>/dev/null | \
            awk '{print $2}' | sed 's|refs/tags/||' | sort -V)
          missing_tags=""
          for tag in $upstream_tags; do
            if ! echo "$origin_tags" | grep -q "^$tag$"; then
              missing_tags="$missing_tags $tag"
              git fetch upstream "refs/tags/$tag:refs/tags/$tag"
              git push origin "refs/tags/$tag:refs/tags/$tag"
              if gh release view "$tag" >/dev/null 2>&1; then
                echo "Release $tag already exists"
              else
                gh release create "$tag" -t "$tag" -n "Mirror of upstream release $tag"
              fi
            fi
          done
          tags_json=$(printf '%s\n' $missing_tags | \
            python -c 'import sys,json; print(json.dumps([t for t in sys.stdin.read().split() if t]))')
          echo "tags=$tags_json" >> $GITHUB_OUTPUT
          latest_tag=$(printf '%s\n' $upstream_tags | tail -n1)
          echo "latest tag is $latest_tag"
          echo "latest_tag=$latest_tag" >> $GITHUB_OUTPUT

  build:
    needs: discover
    if: needs.discover.outputs.tags != '[]'
    strategy:
      fail-fast: false
      matrix:
        tag: ${{ fromJson(needs.discover.outputs.tags) }}
        platform: [macos-15]
    runs-on: ${{ matrix.platform }}
    permissions:
      contents: write
    steps:
      - name: Checkout upstream source
        run: git clone --depth 1 --branch "${{ matrix.tag }}" https://github.com/nirs/vmnet-helper upstream
      - name: Install requirements
        run: brew install meson diffoscope
      - name: Build
        working-directory: upstream
        run: |
          meson setup build
          meson compile -C build
          ./archive.sh build
      - name: Test reproducibility
        working-directory: upstream
        run: |
          meson setup repro
          meson compile -C repro
          ./archive.sh repro
          diffoscope build/vmnet-helper-*.tar.gz repro/vmnet-helper-*.tar.gz
      - name: Upload artifact to release
        env:
          GH_TOKEN: ${{ secrets.MIRROR_TOKEN }}
        working-directory: upstream
        run: |
          set -euo pipefail
          repo="minikube-machine/vmnet-helper"
          tag="${{ matrix.tag }}"
          tarball=$(ls build/vmnet-helper-*.tar.gz)
          if ! gh release view "$tag" --repo "$repo" >/dev/null 2>&1; then
            gh release create "$tag" --repo "$repo" -t "$tag" -n "Mirror of upstream release $tag"
          fi
          gh release upload --repo "$repo" "$tag" "$tarball" --clobber
      - name: Upload latest artifact
        if: matrix.platform == 'macos-15' && matrix.tag == needs.discover.outputs.latest_tag
        uses: actions/upload-artifact@v4
        with:
          name: latest-tarball
          path: upstream/build/vmnet-helper-*.tar.gz

  latest:
    needs: discover
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.MIRROR_TOKEN }}
      - name: Configure git
        run: |
          git config user.name github-actions[bot]
          git config user.email github-actions[bot]@users.noreply.github.com
      - name: Determine highest version tag
        id: highest
        run: |
          set -euo pipefail
          git fetch --tags origin
          tags=$(git tag --list | grep -E '^[0-9]+(\.[0-9]+)*$' || true)
          if [ -z "$tags" ]; then
            echo "No version-like tags found"
            echo "highest=" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          highest=$(printf '%s\n' $tags | sort -V | tail -n1)
          echo "Highest tag: $highest"
          echo "highest=$highest" >> "$GITHUB_OUTPUT"
      - name: Update latest tag and release
        if: steps.highest.outputs.highest != ''
        env:
            GH_TOKEN: ${{ secrets.MIRROR_TOKEN }}
            HIGHEST: ${{ steps.highest.outputs.highest }}
        run: |
          set -euo pipefail
          git fetch --tags origin
          # Point / update local latest tag at highest version
            git tag -f latest "$HIGHEST"
          # Replace remote latest tag
          git push origin :refs/tags/latest || true
          git push origin refs/tags/latest
          # Recreate latest release pointing to the highest version commit
          if gh release view latest >/dev/null 2>&1; then
            gh release delete latest -y
          fi
          gh release create latest --target "$HIGHEST" -t latest -n "Alias for highest version tag: $HIGHEST"